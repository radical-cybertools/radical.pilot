#!/usr/bin/env python3

import re
import os
import sys
import time
import pprint
import signal
import select
import argparse
import threading
import subprocess

import radical.utils as ru


def print(msg):
    sys.stdout.write('%.2f %s\n' % (time.time(), msg))
    sys.stdout.flush()


# ------------------------------------------------------------------------------
#
# This script is a wrapper around an actual executable.  It's purpose is,
# depening on the mode of operation, to either watch the executable's stdout for
# some pattern, or to watch an output file created by the executable for that
# pattern.  If the pattern is found, the matching data is extracted and sent to
# *this* script's stdout.  If the executable returns a non-zero exit code, or if
# a timeout is reached, the script will also return a non-zero exit code.  If
# The script returns a zero exit code but a pattern is provided but not found,
# the script will also return a non-zero exit code.
#
# The script is called with the following arguments:
#
#   -m mode   : data stream to search through, either `stdout` (default),
#               `stderr`, or a file name
#   -p pattern: regex pattern to search for
#   -o output : file name to store the executable's stdout
#   -e error  : file name to store the executable's stderr
#   -t timeout: time in seconds after which the script will terminate if pattern
#               is not found
#   --        : marks the end of the script's arguments and the start of the
#               executable's name and arguments


CHANNEL  = 'control_pubsub'
last_msg = None


# ------------------------------------------------------------------------------
#
def main():

    global last_msg

    print('starting')

    parser = argparse.ArgumentParser(description='')

    parser.add_argument('-c', '--command',  dest='command')
    parser.add_argument('-r', '--registry', dest='reg_url')
    parser.add_argument('-u', '--uid',      dest='uid')
    parser.add_argument('-n', '--name',     dest='name')
    parser.add_argument('-m', '--mode',     dest='mode')
    parser.add_argument('-p', '--pattern',  dest='pattern')
    parser.add_argument('-o', '--output',   dest='output')
    parser.add_argument('-e', '--error',    dest='error')
    parser.add_argument('-v', '--verbose',  dest='verbose', action='store_true')
    parser.add_argument('-t', '--timeout',  dest='timeout')

    args    = parser.parse_args()
    command = args.command or None
    reg_url = args.reg_url or os.environ.get('RP_REGISTRY_ADDRESS')
    uid     = args.uid     or os.environ.get('RP_TASK_ID')
    name    = args.name    or uid
    mode    = args.mode    or 'stdout'
    pattern = args.pattern or '\\<http[s]?://[0-9a-zA-Z\\.:_-]*\\>'
    output  = args.output  or '%s.stdout' % uid
    error   = args.error   or '%s.stderr' % uid
    verbose = args.verbose or False
    timeout = args.timeout or 0

    ranks   = int(os.environ.get('RP_RANKS'))
    rank    = int(os.environ.get('RP_RANK'))

    output  = '%s.%04d' % (output, rank)
    error   = '%s.%04d' % (error,  rank)

    timeout = int(timeout) if timeout else 0

    if not command: raise ValueError('no command given')
    if not uid    : raise ValueError('no uid given')
    if not reg_url: raise ValueError('RP_REGISTRY_ADDRESS not set')

    # get control pubsub from registry
    print('reg_url x: %s' % reg_url)
    reg = ru.zmq.RegistryClient(url=reg_url)

    # test registry
    reg.put('test', 'test')
    reg.dump('test')

    cfg = reg['bridges.%s' % CHANNEL]

    print('pub_url: %s' % cfg['addr_pub'])
    pub = ru.zmq.Publisher(channel=CHANNEL, url=cfg['addr_pub'])

    # let zmq settle
    time.sleep(1.0)

    # run the command
    cmd     = '%s >%s 2>%s' % (command, output, error)
    proc    = None
    match   = None
    err_msg = ''

    watch_event   = threading.Event()
    timeout_event = threading.Event()

    try:
        print('executing: %s' % cmd)
        proc = subprocess.Popen(cmd, shell=True)
        print('pid: %s' % proc.poll())

        if timeout is not None:

            def watch(_proc, _timeout):
                print('start watcher')
                start = time.time()
                while _proc.poll() is None:
                    print('check watcher')
                    time.sleep(0.1)
                    if watch_event.is_set():
                        break
                    if _timeout and time.time() - start > _timeout:
                        print('timeout')
                        timeout_event.set()
                        _proc.kill()
                        break
                print('stop watcher: %s' % _proc.poll())

            watcher = threading.Thread(target=watch, args=(proc, timeout))
            watcher.daemon = True
            watcher.start()

        # open the stream to watch
        fname = None
        if   mode == 'stdout'        : fname = output
        elif mode == 'stderr'        : fname = error
        elif mode.startswith('file:'): fname = mode[5:]

        if not fname:
            if mode:
                raise ValueError('unknown mode %s' % mode)
            return

        fstream = None
        while proc.poll() is None:
            try:
                fstream = open(fname, 'r')
                break
            except:
                time.sleep(0.1)
                continue

        # find pattern
        start = time.time()
        regex = re.compile('^.*(%s).*$' % pattern)
        data  = ''

        print('watching: %s for pattern [%s]' % (fname, pattern))
        if fstream:
            print('watching: %s' % fstream)
            while proc.poll() is None:

                r, _, _ = select.select([fstream], [], [], 0.1)
                if fstream in r:

                    data += str(os.read(fstream.fileno(), 1).decode())

                    if not data.endswith('\n'):
                        continue

                    line = data[:-1]
                    data = ''

                    if verbose:
                        print('line: %s' % line)

                    match = regex.match(line)
                    if match:
                        match = match.groups()[-1]
                        break

                if timeout and time.time() - start > timeout:
                    raise ValueError('timeout')

    except Exception as e:
        err_msg = repr(e)
        raise

    finally:

        # stop the watcher
        if timeout_event.is_set():
            err_msg = 'timeout'
        else:
            watch_event.set()

        if verbose:
            print('stop watcher: %s' % err_msg)

        if proc:
            ret = proc.poll()
            if ret is not None and ret > 0:
                err_msg = 'command failed: %s' % ret

    time.sleep(1)

    # send the result to the agent
    print('send result: %s [%s]' % (match, err_msg))
    msg = {'cmd': 'service_info',
           'arg': {'uid'  : uid,
                   'ranks': ranks,
                   'rank' : rank,
                   'name' : name,
                   'error': err_msg,
                   'info' : match}}

    pprint.pprint(msg)
    pub.put(CHANNEL, msg)

    # register to control pubsub and wait for (hb) messages
    ctrl_addr_sub = reg.get('bridges.%s' % CHANNEL)['addr_sub']

    last_msg = time.time()

    def _ctrl_cb(topic, msg):
        global last_msg
        last_msg = time.time()

    ru.zmq.Subscriber(CHANNEL, ctrl_addr_sub, cb=_ctrl_cb, topic=CHANNEL)

    # now just run intil `cmd` completes and return its exit code
    while proc.poll() is None:
        print('wait: %s' % proc.poll())
        if time.time() - last_msg > 10:
            print('timeout: %s' % proc.poll())
            print('kill %d' % proc.pid)
            print(ru.sh_callout('kill %d' % proc.pid))
            break
        time.sleep(1.0)

    ret = proc.poll()

    print('done: %s' % ret)

    sys.exit(ret)


# ------------------------------------------------------------------------------
#
if __name__ == '__main__':
    main()


# ------------------------------------------------------------------------------

